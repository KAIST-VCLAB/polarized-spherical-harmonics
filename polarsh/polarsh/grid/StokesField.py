from __future__ import annotations
from time import time
from tqdm import tqdm
from typing import Type, List
import math
from pathlib import Path
import numpy as np
from numpy.typing import ArrayLike
import quaternionic as quat
import spherical

from ..array import *
from ..sphere import *
from ..SH import *
from ..polar import stokes_frame_convert
from ..image import *
from ..SHCoeff import SHVec, SHMat
from .Grid import *


class StokesField:
    def __init__(self,
                 SphFF: SphereFrameField, # SphFF.shape: *
                 Stk:   ArrayLike,         # [*g,*c,p] Stokes component vectors, p in [2,3,4]
                ):
        # ---------- Parameter check ----------
        assert isinstance(SphFF, SphereFrameField), type(SphFF)
        Stk = np.asarray(Stk)

        # ---------- Initialize ----------
        self.SphFF = SphFF
        self.SphGrid = SphFF.SphGrid
        assert self.SphGrid.dom_type == DomType.UNI
        self.shape_grid = self.SphGrid.shape
        assert self.shape_grid == SphFF.shape
        self.axes_grid = tuple(range(len(self.shape_grid)))
        self.cod_type = CodType(Stk.shape[-1])
        assert self.cod_type in list(CodType)[1:], f"Stk.shape ({Stk.shape}) must be end with one of CodomTypeList."
        assert Stk.shape[:len(self.shape_grid)] == self.shape_grid, f"The front part of Stk.shape ({Stk.shape}) should be equal to self.shape_grid ({self.shape_grid})"
        self.shape_chan = Stk.shape[len(self.shape_grid):-1]
        self.axes_chan = tuple(range(len(self.shape_grid), Stk.ndim-1))
        self.ndim_grid = len(self.shape_grid)
        self.ndim_chan = len(self.shape_chan)

        self.Stk = Stk
    
    @classmethod
    def from_components(cls,
                        scalF_s0: Union[float, ScalarField],
                        stkF_s12: StokesField,
                        scalF_s3: Optional[Union[float, ScalarField]] = None):
        assert isinstance(stkF_s12, StokesField)
        
        def process_scalar(scalF):
            if isinstance(scalF, ScalarField):
                assert scalF.SphGrid is stkF_s12.SphGrid
                fval = scalF.fval[..., None]
            else:
                assert np.isscalar(scalF)
                fval = np.broadcast_to(scalF, stkF_s12.shape_grid + stkF_s12.shape_chan + (1,))
            return fval
        
        cat_list = [process_scalar(scalF_s0), stkF_s12.Stk]
        
        if not scalF_s3 is None:
            cat_list.append(process_scalar(scalF_s3))

        return cls(stkF_s12.SphFF, np.concatenate(cat_list, -1))

    @classmethod
    def from_cubeimage(cls,
                       filename: Union[str, Path], # exr file (with '%d') generated by mitsuba3
                       base_idx: Optional[int] = 0,
                      ) ->       StokesField:
        ## By concatenating Grid objects
        filename = str(filename)
        for i0, i_file in enumerate(range(base_idx, base_idx + 4)):
            img = imread(filename % i_file)
            if i0 == 0:
                h,w,c = img.shape
                Stk = np.zeros((h,w,c,4))
                edge = cubemap_hw2edge(h, w)
                SMF = SphereFrameField.from_cube(edge)
            Stk[...,i0] = img
        return cls(SMF, envmap_stack(Stk))

    @classmethod
    def from_equirectimage(cls,
                           filename: Union[str, Path], # exr file (with '%d') generated by mitsuba3
                           base_idx: Optional[int] = 0,
                          ) ->       StokesField:
        ## By concatenating Grid objects
        filename = str(filename)
        for i0, i_file in enumerate(range(base_idx, base_idx + 4)):
            img = imread(filename % i_file)
            if i0 == 0:
                h,w,c = img.shape
                Stk = np.zeros((h,w,c,4))
                sphFF = SphereFrameField.from_equirect(h, w)
            Stk[...,i0] = img
        return cls(sphFF, Stk)
    
    @classmethod
    def from_image(cls,
                   filename:  Union[str, Path], # exr file (with '%d') generated by mitsuba3
                   fov_x_deg: float,
                   base_idx:  Optional[int] = 0,
                  ) ->        StokesField:
        for i0, i_file in enumerate(range(base_idx, base_idx + 4)):
            img = imread(filename % i_file)
            if i0 == 0:
                h,w,c = img.shape
                sphFF = SphereFrameField.from_persp(h,w,fov_x_deg)
                Stk = np.zeros((h,w,c,4))
            Stk[...,i0] = img
        return cls(sphFF, Stk)

    @classmethod
    def from_SHCoeff(cls,
                     shv:   SHVec,
                     SphFF: Union[SphereGrid, SphereFrameField],
                     quiet: Optional[bool] = True
                    ) ->    StokesField:
        if not quiet:
            t = time()
            print("\n## [Function start] StokesField.from_SHcoeff")
        assert shv.cod_type in [CodType.POLAR3, CodType.POLAR4] # TODO generalize
        if isinstance(SphFF, SphereGrid):
            SphFF = SphFF.ThetaPhiFrameField()
        assert isinstance(SphFF, SphereFrameField)
        SphGrid = SphFF.SphGrid
        assert SphGrid.dom_type == DomType.UNI
        ## Assert SHcoeff[...,1:3] is virtually real
        if np.iscomplexobj(shv.coeff):
            assert_error_bound(shv.coeff[...,1:3].imag,
                               name="Imaginary part of s2SH coeff. of linear polar'tion.",
                               quiet=quiet)
        ## Deal with sh_type
        if shv.sh_type == SHType.COMP: dtype = np.complex128
        else:                          dtype = np.float64
        
        n_grid = math.prod(SphGrid.shape) # NOTE np.int is weaker to overflow
        shape_chan = shv.coeff.shape[:-2]
        Stk_can = np.zeros(SphGrid.shape + shape_chan + (shv.cod_type,),
                            dtype = dtype)
        Stk_can_short = Stk_can.view().reshape(n_grid, *shape_chan, shv.cod_type)
        
        full_memory = n_grid * shv.N * 16
        n_pass = math.ceil(full_memory / MEMORY_PER_PASS)
        if not quiet and n_pass > 1:
            iter = tqdm(range(n_pass), desc="Seperate passes due to memory")
        else:
            iter = range(n_pass)
        
        for i_pass in iter:
            ## (s2)SHgrid[Ng', N(L)]
            ## SHcoeff[*c, N(L), 4]
            i = n_grid*i_pass // n_pass
            j = n_grid*(i_pass+1) // n_pass
            kargs = {"sh_type":shv.sh_type, "cfg_pass":(i_pass, n_pass)}
            
            ## Scalar components
            if shv.cod_type == CodType.POLAR3:
                sidx = 0
                s_tdot_ax = (-1, -1)
            else:
                sidx = [0,3]
                s_tdot_ax = (-1, -2)
            SHgrid = SphGrid.SH_upto(shv.level, False, **kargs)
            temp = np.tensordot(SHgrid, shv.coeff[...,sidx],
                                axes = s_tdot_ax)
            del SHgrid
            Stk_can_short[i:j, ..., sidx] = temp
            del temp
            
            ## Linear polarization components
            s2SHgrid = SphGrid.SH_upto(shv.level, True, **kargs)
            temp = np.tensordot(s2SHgrid, vec2comp(shv.coeff[...,1:3].real),
                                axes = (-1,-1))
            del s2SHgrid
            Stk_can_short[i:j, ..., 1:3] = comp2vec(temp)
            del temp
        
        StkGrid_can = cls(SphGrid.ThetaPhiFrameField(), Stk_can)
        StkGrid = StkGrid_can.to_SphFF(SphFF)
        if not quiet:
            print(f"## [Function end] time: {time()-t} seconds.")
        return StkGrid
    
    @classmethod
    def from_s2SH_upto(cls,
                       level:   int,
                       SphFF:   Union[SphereGrid, SphereFrameField],
                       rotated: Optional[RotationLike] = None
                      ) ->      StokesField:
        """
        Construct StokesField for spin-2 SH basis functions ($\overset{\leftrightarrow}{Y}_{lm1}$)
        where each (l,m)-index is considered as a channel of the StokesField instance.
        """
        if isinstance(SphFF, SphereGrid):
            SphFF = SphFF.ThetaPhiFrameField()
        assert isinstance(SphFF, SphereFrameField)
        assert SphFF.SphGrid.dom_type == DomType.UNI

        Q = quat.array.from_rotation_matrix(SphFF.F)

        if not rotated is None:
            rotated = rotation2quat(rotated)
            Q = rotated.inverse * Q

        wigner = spherical.Wigner(level-1)
        stkG = StokesField(SphFF, comp2vec(wigner.sYlm(2, Q), axis=-1))
        return stkG
    
    @classmethod
    def from_PSH_upto(cls,
                      level:   int,
                      SphFF:   Union[SphereGrid, SphereFrameField], # [*g]
                      rotated: Optional[RotationLike] = None
                     ) ->      StokesField:                         # [*g | c: N, 4, | p:4]
        """
        Construct StokesField for spin-2 SH basis functions ($\overset{\leftrightarrow}{Y}_{lm1}$)
        where each (l,m)-index is considered as a channel of the StokesField instance.
        """
        if isinstance(SphFF, SphereGrid):
            SphFF = SphFF.ThetaPhiFrameField()
        assert isinstance(SphFF, SphereFrameField)
        sphG = SphFF
        assert SphFF.SphGrid.dom_type == DomType.UNI

        scalF_SH = ScalarField.from_SH_upto(level, sphG, SHType.REAL, rotated=rotated)
        stkF_s2SH = StokesField.from_s2SH_upto(level, SphFF, rotated=rotated)
        N, = scalF_SH.shape_chan
        assert stkF_s2SH.shape_chan == (N,)

        Stk_res = np.zeros(sphG.shape + (N, 4, 4)) # [*g | c:N, 4 | p:4]
        Stk_res[..., 0, 0] = scalF_SH.fval
        Stk_res[..., 1, 1:3] = stkF_s2SH.Stk
        Stk_res[..., 2, 1:3] = (stkF_s2SH * 1j).Stk
        Stk_res[..., 3, 3] = scalF_SH.fval

        return cls(stkF_s2SH.SphFF, Stk_res)

    @classmethod
    def zeros_like(cls,
                   stkF: StokesField
                  ) ->   StokesField:
        return cls(stkF.SphFF, np.zeros_like(stkF.Stk))    

    """
    Recall the assertion
    `assert self.cod_type in list(CodType)[1:]`
    in `__init__`
    """
    def s0(self, keepdims: Optional[bool] = False, fill_zero: Optional[bool] = False
          ) -> ArrayLike:
        if self.cod_type in [CodType.POLAR3, CodType.POLAR4]:
            res = self.Stk[..., 0]
            if keepdims:
                res = np.expand_dims(res, -1)
            return res
        else:
            if fill_zero:
                return 0
            else:
                raise ValueError(f"The instance does not contain s0 Stokes component due to {self.cod_type=}. " +
                                 f"If you want to assume unspecified Stokes components as zero, Set the parameter `fill_zero=True`.")
    def s1(self, keepdims: Optional[bool] = False, fill_zero: Optional[bool] = False
          ) -> ArrayLike:
        res = self.Stk[..., self.cidx_lpolar()][..., 0]
        if keepdims:
            res = np.expand_dims(res, -1)
        return res
    def s2(self, keepdims: Optional[bool] = False, fill_zero: Optional[bool] = False
          ) -> ArrayLike:
        res = self.Stk[..., self.cidx_lpolar()][..., 1]
        if keepdims:
            res = np.expand_dims(res, -1)
        return res
    def s12_comp(self, keepdims: Optional[bool] = False, fill_zero: Optional[bool] = False
                ) -> ArrayLike: # complex
        res = vec2comp(self.Stk[..., self.cidx_lpolar()])
        if keepdims:
            res = np.expand_dims(res, -1)
        return res
    def s3(self, keepdims: Optional[bool] = False, fill_zero: Optional[bool] = False
          ) -> ArrayLike:
        if self.cod_type == CodType.POLAR4:
            res = self.Stk[..., 3]
            if keepdims:
                res = np.expand_dims(res, -1)
            return res
        else:
            if fill_zero:
                return 0
            else:
                raise ValueError(f"The instance does not contain s0 Stokes component due to {self.cod_type=}. " +
                                 f"If you want to assume unspecified Stokes components as zero, Set the parameter `fill_zero=True`.")
    
    def s0_ScalarField(self, fill_zero: Optional[bool] = False) -> ScalarField:
        if (self.cod_type in [CodType.POLAR3, CodType.POLAR4]) or fill_zero:
            return ScalarField(self.SphGrid, self.s0(fill_zero=fill_zero))
        else:
            raise ValueError(f"The instance does not contain s0 Stokes component due to {self.cod_type=}. " +
                             f"If you want to assume unspecified Stokes components as zero, Set the parameter `fill_zero=True`.")
    def s12_StokesField(self) -> StokesField:
        """
        Also called as "spin-2 Stokes vector field" in the paper.
        """
        if self.cod_type == CodType.POLAR2:
            return self
        else:
            return StokesField(self.SphFF, self.Stk[..., self.cidx_lpolar()])
    def s1_ScalarField(self) -> ScalarField:
        """
        [WARN] While results of `self.s0_ScalarField`, `self.s12_StokesField`, and `self.s3_ScalarField` can be considered as geometric objects
        which do not depend on frame fields, results of `self.s1_ScalarField` and `self.s2_ScalarField` depends on the choice of `self.SphFF`.
        """
        return ScalarField(self.SphGrid, self.s1())
    def s2_ScalarField(self) -> ScalarField:
        """
        [WARN] While results of `self.s0_ScalarField`, `self.s12_StokesField`, and `self.s3_ScalarField` can be considered as geometric objects
        which do not depend on frame fields, results of `self.s1_ScalarField` and `self.s2_ScalarField` depends on the choice of `self.SphFF`.
        """
        return ScalarField(self.SphGrid, self.s2())
    def s3_ScalarField(self, fill_zero: Optional[bool] = False) -> ScalarField:
        if (self.cod_type == CodType.POLAR4) or fill_zero:
            return ScalarField(self.SphGrid, self.s3(fill_zero=fill_zero))
        else:
            raise ValueError(f"The instance does not contain s0 Stokes component due to {self.cod_type=}. " +
                             f"If you want to assume unspecified Stokes components as zero, Set the parameter `fill_zero=True`.")

    def to_CodType(self, cod_type: CodType, fill_zero: Optional[bool] = False) -> Union[ScalarField, StokesField]:
        cod_type = CodType(cod_type)
        if cod_type not in list(CodType)[1:]:
            raise ValueError(f"{cod_type=} must be one of `CodType.POLAR2-4`.")
        
        if cod_type == self.cod_type:
            res = self
        # -------------------- Cut --------------------
        elif cod_type < self.cod_type:
            if cod_type == CodType.POLAR2:
                res = StokesField(self.SphFF, self.Stk[..., self.cidx_lpolar()])
            elif cod_type == CodType.POLAR3:
                res = StokesField(self.SphFF, self.Stk[..., :3])
            else:
                raise AssertionError("Unreachable branch. The code is wrong.")
        # -------------------- Zero padding --------------------
        else:
            if fill_zero == False:
                raise ValueError(f"Since ({cod_type=}) > ({self.cod_type=}), the method only work under the argument `fill_zero=True`"
                                 +" in order to enforce users to be aware that the methods fills zero values.")
            Stk = np.zeros(self.SphGrid.shape + (int(cod_type),), dtype=self.Stk.dtype)
            if self.cod_type == CodType.POLAR2:
                Stk[..., 1:3] = self.Stk
            elif self.cod_type == CodType.POLAR3:
                Stk[..., :3] = self.Stk
            else:
                raise AssertionError("Unreachable branch. The code is wrong.")
            res = StokesField(self.SphFF, Stk)
        # -------------------- Final --------------------
        assert res.cod_type == cod_type
        return res


    def __repr__(self):
        def str2(tup: tuple) -> str:
            return str(tup)[1:-1]
        
        result = "StokesField[\n"
        result += f"  dom_type = {repr(self.SphGrid.dom_type)},\n"
        result += f"  Stk.shape = [g:{str2(self.shape_grid)} | c:{str2(self.shape_chan)} | p:{int(self.cod_type)}],\n"
        result += "]"
        return result
    
    def __add__(self, stkG: StokesField) -> StokesField:
        """
        TODO: Broadcasting for `shape_chan`'s??
        """
        assert self.SphGrid is stkG.SphGrid
        assert self.cod_type == stkG.cod_type
        return StokesField(self.SphFF, self.Stk + stkG.wrt_SphFF(self.SphFF))
    def __sub__(self, stkG: StokesField) -> StokesField:
        """
        TODO: Broadcasting for `shape_chan`'s??
        """
        assert self.SphGrid is stkG.SphGrid
        assert self.cod_type == stkG.cod_type
        return StokesField(self.SphFF, self.Stk - stkG.wrt_SphFF(self.SphFF))
    def __mul__(self, x: float) -> StokesField:
        assert np.isscalar(x)
        if np.isrealobj(x):
            return StokesField(self.SphFF, self.Stk * x)
        else:
            if self.cod_type > CodType.POLAR2:
                raise TypeError(f"Scalar multiplication for a `StokesField` with {self.cod_type=} must be done with real number.\n"
                                f"Currently given: {x.dtype = }")
            else:
                Re = self.Stk[..., 0]
                Im = self.Stk[..., 1]
                res_Stk = np.empty_like(self.Stk)
                res_Stk[..., 0] = x.real*Re - x.imag*Im
                res_Stk[..., 1] = x.imag*Re + x.real*Im
                return StokesField(self.SphFF, res_Stk)
        
        
    def __div__(self, x: float) -> StokesField:
        assert np.isscalar(x)
        assert np.isrealobj(x)
        return StokesField(self.SphFF, self.Stk / x)
    def __iadd__(self, stkG: StokesField) -> StokesField:
        assert self.SphGrid is stkG.SphGrid
        assert self.cod_type == stkG.cod_type
        self.Stk += stkG.wrt_SphFF(self.SphFF)
        return self
    def __isub__(self, stkG: StokesField) -> StokesField:
        assert self.SphGrid is stkG.SphGrid
        assert self.cod_type == stkG.cod_type
        self.Stk -= stkG.wrt_SphFF(self.SphFF)
        return self
    
    def allclose(self, stkF: StokesField, rtol: Optional[float]=1e-05, atol: Optional[float]=1e-08) -> bool:
        if not isinstance(stkF, StokesField):
            raise TypeError(f"Invalid type: {type(ScalarField)=}. The type must be `ScalarField`.")
        if not self.SphGrid is stkF.SphGrid:
            raise ValueError(f"`.SphGrid: SphereGrid` attributes of two operands must be an identical instance.")
        if self.cod_type != stkF.cod_type:
            raise ValueError(f"Attributes `cod_type` for `self` and `stkF` must be equal, but currently:\n"
                             f"{self.cod_type = }, {stkF.cod_type = }")
        return np.allclose(self.Stk, stkF.wrt_SphFF(self.SphFF), rtol=rtol, atol=atol)
    
    @property
    def chan(self) -> _StokesField_channel_indexer:
        return _StokesField_channel_indexer(self)

    def save_envmap(self, filename: Union[str,Path]): # filename must contain one '%d'
        ## TODO Make more safe. The current version naively assumes self is for an env. map.
        filename = str(filename)
        Stk_env = envmap_unfold(self.Stk)
        for i in range(4):
            imwrite(filename % (i+1), Stk_env[...,i])
    
    def Stk_weighted(self):
        return self.Stk * np.expand_dims(self.SphGrid.weight(), self.axes_chan + (-1,))

    def to_SphFF(self,
                 SphFF_to, #:  SphereFrameField,
                 allow_nan: bool = False
                )        -> StokesField:
        #* Convert self.Stk w.r.t. given SphFF
        assert self.SphGrid is SphFF_to.SphGrid, "SphGrid attributes in self and SphFF_to should be identical."
        #* self.dom_type == DomType.UNI from __init__
        if self.SphFF is SphFF_to:
            return self
        else:
            M = stokes_frame_convert(self.SphFF.F, SphFF_to.F, cod_type=self.cod_type, allow_nan=allow_nan)
            M = np.expand_dims(M, self.axes_chan)
            return StokesField(SphFF_to, matmul_vec1d(M, self.Stk))
        
    def wrt_SphFF(self,
                  SphFF_to, #:  SphereFrameField,
                  allow_nan: bool = False
                 )        -> np.ndarray:
        return self.to_SphFF(SphFF_to, allow_nan=allow_nan).Stk

    def wrt_equirect(self,
                     h:  int,
                     w:  int
                    ) -> np.ndarray: # [h, w, *c, p]
        StkGrid_can = self.to_SphFF(self.SphGrid.ThetaPhiFrameField())
        Stk_can = StkGrid_can.Stk
        assert not np.isnan(Stk_can).any(), f"Stk_can should not contain Nan, " \
                                            f"but currently {np.isnan(Stk_can).sum()} NaNs in the {Stk_can.shape}-array."
        return ScalarField(self.SphGrid, Stk_can).resample_equirect(h, w)
       
    
    def E_field(self
               )  -> np.ndarray: # [*g, *c, 3(world coord)]
        # TODO: genuine generalization for complex array
        # linpol_comp = vec2comp(self.Stk[..., self.cidx_lpolar()], axis=-1)
        linpol_comp = vec2comp(self.Stk[..., self.cidx_lpolar()].real, axis=-1)
        linpol_abs = np.abs(linpol_comp)
        E_field_local = np.sqrt(linpol_abs*linpol_comp)
        E_field_local = np.stack([E_field_local.real, E_field_local.imag], -1)
        E_field = matmul_vec1d(np.expand_dims(self.SphFF.F[..., :, :2], self.axes_chan), E_field_local)
        return E_field

    def multiply_grid(self, mat: ArrayLike) -> StokesField:
        mat = np.asarray(mat)
        return StokesField(self.SphFF, self.Stk * np.expand_dims(mat, self.axes_chan + (-1,)))
    def multiply_chan(self, mat: ArrayLike) -> StokesField:
        mat = np.asarray(mat)
        return StokesField(self.SphFF, self.Stk * np.expand_dims(mat, -1))

    def apply_rotation(self, rotation: RotationLike):
        SphFF_f = self.SphFF.apply_rotation(rotation)
        return StokesField(SphFF_f, self.Stk)
    
    def apply_mueller(self, M: ArrayLike) -> StokesField:
        '''
        Compute left matrix-multiplication by M.
        '''
        assert M.shape[-2] == M.shape[-1]
        Stk_res = matmul_vec1d(M, self.Stk)
        return StokesField(self.SphFF, Stk_res)

    def cidx_scalar(self):
        return cidx_scalar(self.cod_type)
    def cidx_lpolar(self):
        return cidx_lpolar(self.cod_type)
    
    def inner(self, # *g, *c1 := self.shape_grid, self.shape_chan
              StkGrid:   StokesField,
              chan_tdot: Optional[bool] = False, # False | True
              sum_polar: Optional[bool] = True
             )        -> ArrayLike: # [*c1|*c2, p] | [*c1, *c2, p]
        '''
        Compute the inner product <self, StkGrid> as Stokes fields on S^2.
        
        params:
            self.Stk[*g, *c1, p]:    ArrayLike
            StkGrid.Stk[*g, *c2, p]: ArrayLike
            chan_tdot:               bool
        return:
            INNER[*c, p']: ArrayLike,
        
        where *c == `np.broadcast_shape(*c1, *c2)` if `chan_tdot` == False
                 == `*c1 + *c2`                    if      "      == True
              p' == ()    if `sum_polar` == True
                 == p     if `sum_polar` == False
        
        If two operands have different codomain types, 
        then codomain truncation (func:`truncate_codom`) will be done.
        '''
        assert self.SphGrid is StkGrid.SphGrid
        Stk_arg = StkGrid.to_SphFF(self.SphFF).Stk

        if sum_polar:
            # INNER[*c]
            ax = self.axes_grid + (-1,)
        else:
            # INNER[*c, p]
            ax = self.axes_grid

        if chan_tdot:
            # INNER[*c1, *c2, p']
            res = np.tensordot(self.Stk_weighted().conj(), Stk_arg, axes=(ax, ax))
            if sum_polar:
                return res
            else:
                return np.diagonal(res, axis1=self.ndim_chan, axis2=-1)
        else:
            # INNER[*c1|*c2, p']    (broadcast `*c1` and `*c2`)
            prebc = prebc_chan(self.Stk.shape[:-1], Stk_arg.shape[:-1],
                           len(self.shape_grid), chan_tdot)
            _, ax_exp_self, ax_exp_arg, _ = prebc

            Stk_selfw = np.expand_dims(self.Stk_weighted(), ax_exp_self)
            Stk_arg = np.expand_dims(Stk_arg, ax_exp_arg)
            return np.sum(Stk_selfw.conj() * Stk_arg, axis=ax)
    
    def inner_comp(self,                   # [*g, *c1, 2]
                   stkF:      StokesField, # [*g, *c2, 2]
                   chan_tdot: Optional[bool] = False
                  ) ->        ArrayLike:   # [(*c1|*c2)] complex
        assert self.cod_type == CodType.POLAR2
        assert isinstance(stkF, StokesField)
        assert stkF.cod_type == CodType.POLAR2
        assert self.SphGrid is stkF.SphGrid

        
        Stk = self.s12_comp().conj()
        Stk_arg = stkF.to_SphFF(self.SphFF).s12_comp()
        _, ax_exp1, ax_exp2, ax_common = prebc_chan(Stk.shape, Stk_arg.shape, self.ndim_grid, chan_tdot)
        Stk_res = np.expand_dims(Stk, ax_exp1) * np.expand_dims(Stk_arg, ax_exp2)
        Stk_res *= np.expand_dims(self.SphGrid.weight(), ax_common)
        return np.sum(Stk_res, self.axes_grid)

    def normsq(self, sum_LP: Optional[bool] = False) -> np.ndarray:
        """
        return:
            res[*c, p] if sum_LP == False
            res[*c, p'] if sum_LP == True, where p' count p=1 and p=2 as a single index
        TODO needs sophiscated validation
        """
        res = self.inner(self, chan_tdot=False, sum_polar=False)
        if sum_LP:
            idx_sc = cidx_scalar(self.cod_type)
            idx_lp = cidx_lpolar(self.cod_type)
            res_sc = res[..., idx_sc]
            res_lpsum = res[..., idx_lp].sum(-1)[..., None]
            res = np.concatenate([res_sc[..., 0:1], res_lpsum, res_sc[..., 1:2]], axis=-1)
        return res


    def dot_sarray(self, # [*g, *c1, p] for self.Stk, where *g := shape_grid, *c1 := shape_chan
                   Stk,  # [*g, *c2]
                   pidx:      Optional[Tuple] = (0,3),
                   chan_tdot: Optional[bool] = False, # False | True
                   allow_nan: Optional[bool] = False  # Treat NaN as zero, if true
                  ) -> ArrayLike: # [*g, (*c1|*c2), len(pidx)] | [*g, *c1, *c2, len(pidx)]
        ## NOTE w/o complex conjugate
        assert self.Stk.shape[-1] == 4 # TODO generalize
        #* Deal with allow_nan
        if allow_nan: sum_curr = np.nansum
        else: sum_curr = np.sum

        #* Deal with channel tensor/elementwise product
        prebc = prebc_chan(self.Stk.shape[:-1], Stk.shape,
                           len(self.shape_grid), chan_tdot)
        sh_ch_res, ax_exp_self, ax_exp_arg, ax_exp_w = prebc
        
        #* Broadcast
        Stk_arg = np.expand_dims(Stk, ax_exp_arg)
        Stk_self = self.Stk[...,pidx]
        Stk_self = np.expand_dims(Stk_self, ax_exp_self)
        weight = np.expand_dims(self.SphGrid.weight(), ax_exp_w)

        #* To save memory, execute for loop for each Mueller component
        size_stk = Stk_self.shape[-1]
        DOT = np.zeros(sh_ch_res + (size_stk,),
                       dtype = common_dtype(Stk_self, Stk_arg))
        for p in range(size_stk):
            prod = Stk_self[...,p]*Stk_arg*weight
            DOT[...,p] = sum_curr(prod, axis=self.axes_grid)
            del prod
        return DOT
    
    def dot_varray(self, # *g x *c1 x p for self.Stk, where *g := shape_grid, *c1 := shape_chan
                   Stk,  # *g x *c2 x p
                   chan_tdot: bool = False, # False | True
                   allow_nan: bool = False  # Treat NaN as zero, if true
                  ) -> ArrayLike: # *gx(*c1|*c2) | *gx*c1x*c2
        ## NOTE w/o complex conjugate
        assert self.Stk.shape[-1] == 4 # TODO generalize
        assert Stk.shape[-1] in [2, 4] # TODO generalize
        ## Deal with allow_nan
        if allow_nan: sum_curr = np.nansum
        else: sum_curr = np.sum

        ## Deal with channel tensor/elementwise product
        if Stk.shape[-1] == 2:
            Stk_self = self.Stk[...,1:3]
        else: # Stk.shape[-1] == 4
            Stk_self = self.Stk

        prebc = prebc_chan(Stk_self.shape[:-1], Stk.shape[:-1],
                           len(self.shape_grid), chan_tdot)
        sh_ch_res, ax_exp_self, ax_exp_arg, ax_exp_w = prebc
        
        Stk_arg = np.expand_dims(Stk, ax_exp_arg)
        Stk_self = np.expand_dims(Stk_self, ax_exp_self)
        weight = np.expand_dims(self.SphGrid.weight(), ax_exp_w)

        ## To save memory, execute for loop for each Mueller component
        DOT = np.zeros(sh_ch_res, dtype=common_dtype(Stk_self, Stk_arg))
        for p in range(Stk_self.shape[-1]):
            prod = Stk_self[...,p]*Stk_arg[...,p]*weight
            DOT += sum_curr(prod, axis=self.axes_grid)
        return DOT
        
    def SHCoeff(self, # .Stk[*g, *c, p], where *g := shape_grid, *c := shape_chan
                level:   int,
                sh_type: SHType = SHType.REAL,
                quiet:   bool = True
               )      -> SHVec: # [*c, N(L), p]
        """
        sh_type: SHType.REAL: real scalar SH for s0 and s3, spin-2 SH for s1 and s2 (recommended)
                 SHType.COMP: complex scalar SH for s0 and s3, spin-2 SH for s1 and s2 (only for intermediate computation)
        NOTE via iteration rather than vectorization
             for O(|grid| + N(L)) memory
        """
        if not quiet:
            t = time()
            print("\n## [Function start] StokesField.SHCoeff")
        sh_type = SHType(sh_type)
        cod_type = self.cod_type
        idx_sc = self.cidx_scalar()
        idx_lp = self.cidx_lpolar()
        CanMF = self.SphGrid.ThetaPhiFrameField()
        Stk_can = self.to_SphFF(CanMF)

        ## SphFF.F: shape_grid x 3 x 3
        ## Stk:     shape_grid x shape_chan x 4
        
        n_grid = math.prod(self.shape_grid) # NOTE np.int is more weak to overflow
        N_lm = level2num(level, DomType.UNI)
        shape_re = (n_grid,) + self.shape_chan + (-1,)
        Stk_self = Stk_can.Stk_weighted().view().reshape(shape_re) # [Ng,*c,p]
        
        full_memory = n_grid * N_lm * 16
        n_pass = math.ceil(full_memory / MEMORY_PER_PASS)
        
        if sh_type == SHType.COMP:
            res_dtype = np.complex128
        else:
            res_dtype = np.float64
        res = np.zeros(self.shape_chan + (N_lm, cod_type), dtype=res_dtype)
        
        iter = range(n_pass)
        if not quiet and n_pass > 1:
            iter = tqdm(iter, desc="Seperate passes due to memory")
            
        for i_pass in iter:
            i = n_grid*i_pass // n_pass
            j = n_grid*(i_pass+1) // n_pass
            kargs = {"sh_type":sh_type, "cfg_pass":(i_pass, n_pass)}
            
            ## Scalar components
            Stk_self_scalar = Stk_self[i:j, ..., [0,3]]
            SHgrid = self.SphGrid.SH_upto(level, False, **kargs) # [Ng',N(L)]
            temp = np.tensordot(Stk_self_scalar, SHgrid.conj(),
                                axes=(0,0)) # [*c,p',N(L)]
            del Stk_self_scalar, SHgrid
            temp = np.moveaxis(temp, -2, -1) # [*c,N(L),p']
                
            res[...,idx_sc] += temp
            del temp
            
            ## Linear polarization components
            Stk_self_lp = vec2comp(Stk_self[i:j, ..., 1:3])
            s2SHgrid = self.SphGrid.SH_upto(level, True, **kargs)
            temp = np.tensordot(Stk_self_lp, s2SHgrid.conj(),
                                axes=(0,0)) # [*c,N(L)]
            del Stk_self_lp, s2SHgrid
            res[...,idx_lp] += comp2vec(temp)
            del temp

        res_shv = SHVec(res, self.cod_type, sh_type)
        if not quiet:
            print(f"## [Function end] time: {time()-t} seconds.")
        return res_shv

    def nvSHcoeff(self,
                  level:   int,
                  sh_type: SHType = SHType.COMP,
                  quiet:   bool = True
                 )      -> ArrayLike: # shape_chan x N(L) x p
        if not quiet:
            t = time()
            print("\n## [Function start] StokesField.nvSHcoeff")
        sh_type = SHType(sh_type)
        CanMF = self.SphGrid.ThetaPhiFrameField()
        Stk_can = self.to_SphFF(CanMF)
        if sh_type == SHType.COMP:
            res_dtype = np.complex128
        else:
            res_dtype = np.float64

        
        # ---------- Memory managing ----------
        n_grid = math.prod(self.shape_grid) # NOTE np.int is more weak to overflow
        N = level2num(level, DomType.UNI)
        shape_re = (n_grid,) + self.shape_chan + (-1,)
        Stk_self = Stk_can.Stk_weighted().view().reshape(shape_re) # [Ng,*c,p]

        full_memory = n_grid * N * 16
        n_pass = math.ceil(full_memory / MEMORY_PER_PASS)
        iter = range(n_pass)
        if not quiet and n_pass > 1:
            iter = tqdm(iter, desc="Seperate passes due to memory")
        
        # ---------- Main ----------
        res = np.zeros(self.shape_chan + (N, int(self.cod_type)), dtype=res_dtype)
        for i_pass in iter:    
            i = n_grid*i_pass // n_pass
            j = n_grid*(i_pass+1) // n_pass
            kargs = {"sh_type":sh_type, "cfg_pass":(i_pass, n_pass)}
            
            ## Scalar components
            Stk_pass = Stk_self[i:j, ...]
            SHgrid = self.SphGrid.SH_upto(level, False, **kargs) # [Ng',N(L)]
            temp = np.tensordot(Stk_pass, SHgrid.conj(),
                                axes=(0,0)) # [*c,p',N(L)]
            del Stk_pass, SHgrid
            temp = np.moveaxis(temp, -2, -1) # [*c,N(L),p']
            res += temp
            del temp

        if not quiet:
            print(f"## [Function end] time: {time()-t} seconds.")
        return res
    
    def __E_field_for_plot(self,
                           chan_id: Optional[Union[int, Sequence[int]]] = None
                          ) ->      np.ndarray: #[*g, 3]
        E_field = self.E_field() # [*g, *c, 3]

        if chan_id is None:
            if self.shape_chan == (3,):
                return plot.rgb2gray(E_field, -2)
            elif np.prod(self.shape_chan) == 1:
                return np.squeeze(E_field, self.axes_chan)
            else:
                raise ValueError(f"Only supports channel shape (), (1,), and (3,) for `ScalarField` instance, but {self.shape_chan} given.")
            
        
        elif isinstance(chan_id, int) or (hasattr(chan_id, 'shape') and chan_id.shape == ()):
            return E_field[..., chan_id, :]
        
        elif hasattr(chan_id, "__len__"):
            if len(chan_id) == 3:
                return E_field[..., chan_id, :]
            else:
                raise ValueError(f"`chan_id` must be an integer or a tuple of three integers, but ({type(chan_id)}) {chan_id=} given.")
        else:
            raise ValueError(f"`chan_id` must be an integer or a tuple of two or three integers, but ({type(chan_id)}) {chan_id=} given.")

    def visualize(self,
                  chan_id:      Optional[Union[int, Sequence[int]]] = None,
                  marker_size:  Optional[float] = 5.0,
                  marker_dsamp: Optional[int] = 1,
                  color_scale:     Optional[float] = 1.0,
                  color_gamma:     Optional[float] = None,
                  cmap:      Optional[Union[str, plot.Colormap, Callable]] = None,
                  arrow_scale:  Optional[float] = None, # 0.1
                  arrow_gamma:  Optional[float] = None, # 1.0,
                  arrow_color:  Optional[str]   = None, # 'black',
                  arrow_dsamp:  Optional[int]   = None, # 1,
                  title:        Optional[str]   = None,
                  help:         Optional[bool]  = None):
        # ---------- Default arguments ----------
        arg_dict = plot.args_None2options(cmap=cmap, arrow_scale=arrow_scale, arrow_gamma=arrow_gamma,
                                          arrow_color=arrow_color, arrow_dsamp=arrow_dsamp, help=help)
        cmap = arg_dict['cmap']; arrow_scale = arg_dict['arrow_scale']; arrow_gamma = arg_dict['arrow_gamma']
        arrow_color = arg_dict['arrow_color']; arrow_dsamp = arg_dict['arrow_dsamp']
        help = arg_dict['help']

        # ---------- Show base objects ----------
        canvas, view = plot.gen_vispy_canvas()
        axes, event_a = plot.gen_vispy_axes(view.scene)
        
        if self.cod_type == CodType.POLAR2:
            sphere = vispy.scene.visuals.Sphere(radius=0.999999,
                                                color=(0.99, 0.99, 0.99, 1),
                                                parent=view.scene)
        else:
            s0 = self.s0_ScalarField()
            sphere, grid, *wrap_meshes, event_v = s0.gen_vispy_objs(view.scene,
                                                              chan_id=chan_id,
                                                              marker_size=marker_size,
                                                              marker_dsamp=marker_dsamp,
                                                              scale=color_scale,
                                                              gamma=color_gamma,
                                                              cmap=cmap)
                                                                
        flag_s0texture = (self.cod_type != CodType.POLAR2) and (event_v is not None)

        # ---------- Show linear polarization ----------
        idx_exp = self.SphGrid.dsamp_index_exp(arrow_dsamp)
        E_field = self.__E_field_for_plot(chan_id)
        E_field = E_field[idx_exp].reshape(-1, 3)
        E_field_scale = np.linalg.norm(E_field*arrow_scale, 2, -1, keepdims=True)[..., None] ** (arrow_gamma)
        # E_field[n, 3] and E_field_scale[n, 1, 1] for broadcatability with transform matrices

        mask = E_field_scale.squeeze((-2, -1)) > 0.0

        if mask.sum() > 0:
            E_field = E_field[mask, :]
            E_field_scale = E_field_scale[mask, :, :]

            inst_pos = self.SphGrid.vec[idx_exp].reshape(-1, 3)[mask, :]
            inst_tf = E_field_scale * vec2Ftp(E_field) # Any other vec2Fxx is fine.

            stk = vispy.scene.visuals.InstancedMesh(
                plot.visBiArrow.vertices,
                plot.visBiArrow.faces,
                color=arrow_color,
                instance_positions=inst_pos,
                instance_transforms=inst_tf,
                parent=view.scene
            )
        
        # ---------- finish ----------
        @canvas.events.key_press.connect
        def on_key_press(event):
            if event.key == "a":
                event_a()
            elif event.key == "0":
                if flag_s0texture:
                    event_v()
        
        if help:
            print("[Keyboard interface]\n" + \
                  ("0: texture/point cloud mode for s0 component\n" if flag_s0texture else "") + \
                  "A: hide/show global axes")
        if title is not None:
            plot.vispy_attach_title(view, title)
        return canvas

class _StokesField_channel_indexer:
    def __init__(self, obj: StokesField):
        self.obj = obj
        self.p = int(obj.cod_type)
    def __getitem__(self, key):
        key_grid = tuple(slice(None, None, None) for _ in self.obj.shape_grid)
        if not isinstance(key, tuple):
            key = (key, )
        key_res = key_grid + key
        return StokesField(self.obj.SphFF, self.obj.Stk[key_res])
    
    def __mul__(self, arr: ArrayLike) -> StokesField:
        arr = np.asarray(arr)
        Stk_self = self.broadcast_self_with(arr)
        arr = self.broadcast_array(arr)

        if np.isrealobj(arr):
            return StokesField(self.obj.SphFF, Stk_self * arr[..., None])
        else:
            if self.obj.cod_type > CodType.POLAR2:
                raise TypeError(f"Scalar multiplication for a `StokesField` with {self.cod_type=} must be done with real number.\n"
                                f"Currently given: {arr.dtype = }")
            else:
                Re = Stk_self[..., 0]
                Im = Stk_self[..., 1]
                res_Stk = np.empty_like(Stk_self)
                res_Stk[..., 0] = arr.real*Re - arr.imag*Im
                res_Stk[..., 1] = arr.imag*Re + arr.real*Im
                return StokesField(self.obj.SphFF, res_Stk)
        
    def __div__(self, arr: ArrayLike) -> StokesField:
        if np.iscomplexobj(arr) and self.obj.cod_type > CodType.POLAR2:
            raise TypeError(f"Scalar multiplication for a `StokesField` with {self.cod_type=} must be done with real number.\n"
                            f"Currently given: {arr.dtype = }")        
        return self * (1/arr)
    
    def broadcast_array(self,            # [*g, *c1, p]
                        arr: ArrayLike   # [*c2]
                       ) ->  np.ndarray: # [*c1|*c2]
        arr = np.asarray(arr)
        shape_bc = np.broadcast_shapes(arr.shape, self.obj.shape_chan)
        return np.broadcast_to(arr, shape_bc)
    def broadcast_self_with(self,            # [*g, *c1, p]
                            arr: ArrayLike   # [*c2]
                           ) ->  np.ndarray: # [*c1|*c2, p]
        arr = np.asarray(arr)
        shape_bc = np.broadcast_shapes(arr.shape, self.obj.shape_chan)
        ndim_grid = self.obj.ndim_grid
        ndim_chan_diff = len(shape_bc) - self.obj.ndim_chan
        ax_expdims = tuple(range(ndim_grid, ndim_grid + ndim_chan_diff))
        return np.broadcast_to(np.expand_dims(self.obj.Stk, ax_expdims),
                               self.obj.shape_grid + shape_bc + (self.p,))
    
    def rgb2gray(self):
        if self.obj.shape_chan != (3,):
            raise ValueError(f"Invalid channel shape for the `StokesField` instance: {self.obj.shape_chan}")
        return StokesField(self.obj.SphFF, plot.rgb2gray(self.obj.Stk, -2))
